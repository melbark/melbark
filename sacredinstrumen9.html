<!DOCTYPE html>
<html>
<head>
<title>Page Title</title>
</head>
<body>
<!-- <canvas id="canvas1"></canvas> -->

                    
<div id="guiContainer"></div>
<div id="guiSynthContainer"></div>
<div id="guiFxContainer"></div>


<script src="http://40.115.69.186:3000/js/midiconvert.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/13.3.8/Tone.min.js"></script>
<!-- <script src="https://cdn.jsdelivr.net/npm/@magenta/music@^1.0.1"></script> -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.14.2/dist/tf.min.js"></script>
<script type="text/javascript" src="https://fastcdn.org/FileSaver.js/1.1.20151003/FileSaver.js" ></script>
<script src ="https://rawgit.com/eligrey/canvas-toBlob.js/master/canvas-toBlob.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.2/dat.gui.min.js"></script>
<script src="https://rawgit.com/nexus-js/ui/master/dist/NexusUI.js"></script>
<script src="https://s3-us-west-1.amazonaws.com/luisbergmann.com/libraries/audiokeys.js"></script>  


<script>



// draw canvas
// append canvas to doc
// attach eventhandler
// synthovoice

// By Simon Sarris
// www.simonsarris.com
// my name @gmail.com
//
// Last update December 2011
//
// Free to use and distribute at will
// So long as you are nice to people, etc

// Constructor for Shape objects to hold data for all drawn objects.
// For now they will just be defined as rectangles.
function Shape(x, y, w, h, fill,synth,note) {
  // This is a very simple and unsafe constructor. All we're doing is checking if the values exist.
  // "x || 0" just means "if there is a value for x, use that. Otherwise use 0."
  // But we aren't checking anything else! We could put "Lalala" for the value of x 
  this.x = x || 0;
  this.y = y || 0;
  this.w = w || 1;
  this.h = h || 1;
  this.fill = fill || '#AAAAAA';
  this.synth = synth
  this.note = note || "C3"
  this.pointerid 
}

// Draws this shape to a given context
Shape.prototype.draw = function(ctx) {
  ctx.fillStyle = this.fill;
//   ctx.fillRect(this.x+this.w/4, this.y+this.h/4, this.w/2, this.h/2);
  ctx.fillRect(this.x, this.y, this.w, this.h);
}


Shape.prototype.play = function() {
    this.synth.synth.triggerAttack(this.note)


}

Shape.prototype.update = function() {
    this.synth.synth.update(this.note)

}

Shape.prototype.stop = function() {
    this.synth.synth.triggerRelease(this.note)


}
// Determine if a point is inside the shape's bounds
Shape.prototype.contains = function(mx, my) {
  // All we have to do is make sure the Mouse X,Y fall in the area between
  // the shape's X and (X + Width) and its Y and (Y + Height)
  return  (this.x <= mx) && (this.x + this.w >= mx) &&
          (this.y <= my) && (this.y + this.h >= my);
}

Shape.prototype.leavebox = function(mx, my) {
  // All we have to do is make sure the Mouse X,Y fall in the area between
  // the shape's X and (X + Width) and its Y and (Y + Height)
  return  (this.x+this.w/8 <= mx) && (this.x + this.w/8 >= mx) &&
          (this.y + this.w/8<= my) && (this.y + this.h + this.h/8 >= my);
}



function CanvasState(canvas) {
  // **** First some setup! ****
  
  this.canvas = canvas;
  this.width = canvas.width;
  this.height = canvas.height;
  this.ctx = canvas.getContext('2d');
  // This complicates things a little but but fixes mouse co-ordinate problems
  // when there's a border or padding. See getMouse for more detail
  var stylePaddingLeft, stylePaddingTop, styleBorderLeft, styleBorderTop;
  if (document.defaultView && document.defaultView.getComputedStyle) {
    this.stylePaddingLeft = parseInt(document.defaultView.getComputedStyle(canvas, null)['paddingLeft'], 10)      || 0;
    this.stylePaddingTop  = parseInt(document.defaultView.getComputedStyle(canvas, null)['paddingTop'], 10)       || 0;
    this.styleBorderLeft  = parseInt(document.defaultView.getComputedStyle(canvas, null)['borderLeftWidth'], 10)  || 0;
    this.styleBorderTop   = parseInt(document.defaultView.getComputedStyle(canvas, null)['borderTopWidth'], 10)   || 0;
  }
  // Some pages have fixed-position bars (like the stumbleupon bar) at the top or left of the page
  // They will mess up mouse coordinates and this fixes that
  var html = document.body.parentNode;
  this.htmlTop = html.offsetTop;
  this.htmlLeft = html.offsetLeft;

  // **** Keep track of state! ****
  
  this.valid = false; // when set to false, the canvas will redraw everything
  this.shapes = [];  // the collection of things to be drawn
  this.dragging = false; // Keep track of when we are dragging
  // the current selected object. In the future we could turn this into an array for multiple selection
  this.selection = null;
  this.dragoffx = 0; // See mousedown and mousemove events for explanation
  this.dragoffy = 0;
  this.shapes = {}
  
  // **** Then events! ****
  
  // This is an example of a closure!
  // Right here "this" means the CanvasState. But we are making events on the Canvas itself,
  // and when the events are fired on the canvas the variable "this" is going to mean the canvas!
  // Since we still want to use this particular CanvasState in the events we have to save a reference to it.
  // This is our reference!
  var myState = this;
  

  //fixes a problem where double clicking causes text to get selected on the canvas
  canvas.addEventListener('selectstart', function(e) { e.preventDefault(); return false; }, false);
  // Up, down, and move are for dragging


   
  canvas.addEventListener('pointerdown', function(e) {
      e.preventDefault()
    
    var mouse = myState.getMouse(e);
    var mx = mouse.x;
    var my = mouse.y;
    var shapes = s.shapes;
    // var l = shapes.length;


    for (mySel in shapes) { 

        if (mySel !== undefined) {
            // console.log(mySel)

            var mySel = shapes[mySel]
        if (mySel.contains(mx,my)) {
            mySel.play()
            mySel.dragging = true

        }
        // mySel.play()
        // sacredshapes[e.pointerid] = mySel

        mySel.pointerid = e.pointerid


        }
        
    }

    // for (var i = l-1; i >= 0; i--) {
    //   if (shapes[i].contains(mx, my)) {
    //     var mySel = shapes[i];
    //     if (mySel.leavebox(mx,my)) {
    //         mysel.stop

    //     }
    //     mySel.play()
    //     sacredshapes[e.pointerid] = mySel

    //     mySel.pointerid = e.pointerid
    //     // Keep track of where in the object we clicked
    //     // so we can move it smoothly (see mousemove)
    //     // myState.dragoffx = mx - mySel.x;
    //     // myState.dragoffy = my - mySel.y;
    //     myState.dragging = true;
    //     myState.selection = mySel;
    //     myState.valid = false;
       
    //     return;
    //   }
    // }
    // havent returned means we have failed to select anything.
    // If there was an object selected, we deselect it
    if (myState.selection) {
      myState.selection = null;
      myState.valid = false; // Need to clear the old selection border
    }
  }, true);


  
  canvas.addEventListener('pointermove', function(e) {
      e.preventDefault()
    // console.log(e.pointerType)
    if (e.pointerType == "touch") {
    var mouse = myState.getMouse(e);
    var mx = mouse.x;
    var my = mouse.y;
    var shapes = s.shapes;
    // var l = shapes.length;


    for (mySel in shapes) { 

        if (mySel !== undefined) {
            // console.log(mySel)

            var mySel = shapes[mySel]
        if (mySel.contains(mx,my)) {
            if (mySel.dragging) {
                mySel.update()
            }
            else {
                mySel.play()
            }
         

        }
        else {
            mySel.stop()
        }
        // mySel.play()
        // sacredshapes[e.pointerid] = mySel
        // mysel.stop()
        // mySel.pointerid = e.pointerid
        }

        
        
    }

    // for (var i = l-1; i >= 0; i
    // havent returned means we have failed to select anything.
    // If there was an object selected, we deselect it
    if (myState.selection) {
      myState.selection = null;
      myState.valid = false; // Need to clear the old selection border
    }

}
  }, true);

  
  canvas.addEventListener('pointerup', function(e) {
      e.preventDefault()
    
    var mouse = myState.getMouse(e);
    var mx = mouse.x;
    var my = mouse.y;
    var shapes = s.shapes;
    // var l = shapes.length;


    for (mySel in shapes) { 

        if (mySel !== undefined) {
            // console.log(mySel)

            var mySel = shapes[mySel]
        if (mySel.contains(mx,my)) {
            mySel.stop()
            mySel.dragging  = false

        }
        // mySel.play()
        // sacredshapes[e.pointerid] = mySel

        mySel.pointerid = e.pointerid


        }
        
    }

    // If there was an object selected, we deselect it
    if (myState.selection) {
      myState.selection = null;
      myState.valid = false; // Need to clear the old selection border
    }
  }, true);

//   canvas.addEventListener('pointermove', function(e) {
//     var mouse = myState.getMouse(e);
//     // console.log(e)
//     var mx = mouse.x;
//     var my = mouse.y;
//     var shapes = myState.shapes;
//     var l = shapes.length;
     
//     mySel = sacredshapes[e.pointerid]
//     if (mySel.contains(mx, my)) {

//     //   console.log("still going")


//     }
//     else {

//         mySel.stop()


//     }

//     // if (myState.dragging){
//     //   var mouse = myState.getMouse(e);
//       // We don't want to drag the object by its top-left corner, we want to drag it
//       // from where we clicked. Thats why we saved the offset and use it here
//       // myState.selection.x = mouse.x - myState.dragoffx;
//       // myState.selection.y = mouse.y - myState.dragoffy;   
//       // myState.selection = mySel;
    
//     for (var i = l-1; i >= 0; i--) {
//       if (shapes[i].contains(mx, my)) {
//         var mySel = shapes[i];
        
//         // mySel.play()
//         return;
//       }
//       else {
//         var mySel = shapes[i];
//         mySel.stop()
//         return;
//       }
//     }
//       myState.valid = false; // Something's dragging so we must redraw
     
//     // }
//   }, true);
  canvas.addEventListener('pointerup', function(e) {
    myState.dragging = false;
    var mouse = myState.getMouse(e);
    var mx = mouse.x;
    var my = mouse.y;
    var shapes = myState.shapes;

    
    for (mySel in shapes) {
        var mySel = shapes[mySel]
        if (mySel.contains(mx,my)) {
            mysel.stop

        }
        // mySel.play()
        // sacredshapes[e.pointerid] = mySel

        // mySel.pointerid = e.pointerid



    // var l = shapes.length;
    // myState.selection = mySel;
    // for (var i = l-1; i >= 0; i--) {
    //   if (shapes[i].contains(mx, my)) {
    //     var mySel = shapes[i];
    //     // Keep track of where in the object we clicked
    //     // so we can move it smoothly (see mousemove)
        
    //     mySel.stop()
        return;
      }
    // }
  }, true);

//   canvas.addEventListener('pointercancel', function(e) {
//     myState.dragging = false;
//     var mouse = myState.getMouse(e);
//     var mx = mouse.x;
//     var my = mouse.y;
//     var shapes = myState.shapes;
//     var l = shapes.length;
//     myState.selection = mySel;
//     for (var i = l-1; i >= 0; i--) {
//       if (shapes[i].contains(mx, my)) {
//         var mySel = shapes[i];
//         // Keep track of where in the object we clicked
//         // so we can move it smoothly (see mousemove)
        
//         mySel.stop()
//         return;
//       }
//     }
//   }, true);

//   canvas.addEventListener('pointerleave', function(e) {
//     myState.dragging = false;
//     var mouse = myState.getMouse(e);
//     var mx = mouse.x;
//     var my = mouse.y;
//     var shapes = myState.shapes;
//     var l = shapes.length;
//     myState.selection = mySel;
//     for (var i = l-1; i >= 0; i--) {
//       if (shapes[i].contains(mx, my)) {
//         var mySel = shapes[i];
//         // Keep track of where in the object we clicked
//         // so we can move it smoothly (see mousemove)
        
//         mySel.stop()
//         return;
//       }
//     }
//   }, true);

  
//   canvas.addEventListener('pointerout', function(e) {
//     myState.dragging = false;
//     var mouse = myState.getMouse(e);
//     var mx = mouse.x;
//     var my = mouse.y;
//     var shapes = myState.shapes;
//     var l = shapes.length;
//     myState.selection = mySel;
//     for (var i = l-1; i >= 0; i--) {
//       if (shapes[i].contains(mx, my)) {
//         var mySel = shapes[i];
//         // Keep track of where in the object we clicked
//         // so we can move it smoothly (see mousemove)
        
//         mySel.stop()
//         return;
//       }
//     }
//   }, true);
//   // double click for making new shapes
//   canvas.addEventListener('dblclick', function(e) {
//     var mouse = myState.getMouse(e);
//     myState.addShape(new Shape(mouse.x - 10, mouse.y - 10, 20, 20, 'rgba(0,255,0,.6)'));
//   }, true);
  
  // **** Options! ****
  
  this.selectionColor = '#CC0000';
  this.selectionWidth = 2;  
  this.interval = 30;
//   setInterval(function() { myState.draw(); }, myState.interval);
}

CanvasState.prototype.addShape = function(shape,noteid) {
  this.shapes[noteid] = shape;
  this.valid = false;
}

CanvasState.prototype.clear = function() {
//   this.ctx.clearRect(0, 0, this.width, this.height);
}

// While draw is called as often as the INTERVAL variable demands,
// It only ever does something if the canvas gets invalidated by our code
CanvasState.prototype.draw = function() {
  // if our state is invalid, redraw and validate!
  if (!this.valid) {
    var ctx = this.ctx;
    var shapes = this.shapes;
    // this.clear();
    
    // ** Add stuff you want drawn in the background all the time here **
    
    // draw all shapes
    // var l = shapes.length;
    for (shape in shapes){
    // for (var i = 0; i < l; i++) {
      var shape = shapes[shape];
      // We can skip the drawing of elements that have moved off the screen:
      if (shape.x > this.width || shape.y > this.height ||
          shape.x + shape.w < 0 || shape.y + shape.h < 0) continue;
          shape.draw(ctx);
    //   shapes[i].play()
    }
    
    // draw selection
    // right now this is just a stroke along the edge of the selected Shape
    if (this.selection != null) {
      ctx.strokeStyle = this.selectionColor;
      ctx.lineWidth = this.selectionWidth;
      var mySel = this.selection;
      ctx.strokeRect(mySel.x,mySel.y,mySel.w,mySel.h);
    }
    

    // ** Add stuff you want drawn on top all the time here **
    
    this.valid = true;
  }
}


// Creates an object with x and y defined, set to the mouse position relative to the state's canvas
// If you wanna be super-correct this can be tricky, we have to worry about padding and borders
CanvasState.prototype.getMouse = function(e) {
  var element = this.canvas, offsetX = 0, offsetY = 0, mx, my;
  
  // Compute the total offset
  if (element.offsetParent !== undefined) {
    do {
      offsetX += element.offsetLeft;
      offsetY += element.offsetTop;
    } while ((element = element.offsetParent));
  }

  // Add padding and border style widths to offset
  // Also add the <html> offsets in case there's a position:fixed bar
  offsetX += this.stylePaddingLeft + this.styleBorderLeft + this.htmlLeft;
  offsetY += this.stylePaddingTop + this.styleBorderTop + this.htmlTop;

  mx = e.pageX - offsetX;
  my = e.pageY - offsetY;
  
  // We return a simple javascript object (a hash) with x and y defined
  return {x: mx, y: my};
}

// If you dont want to use <body onLoad='init()'>
// You could uncomment this init() reference and place the script reference inside the body tag
//init();
// init()
// function init() {
    



    

var fx, inst1;
var oscilloscope, piano;

// Unfocus the textbox
function blurAll() {
//   var tmp = document.createElement("input");
//   document.body.appendChild(tmp);
//   tmp.focus();
//   document.body.removeChild(tmp);
}

function initNexus() {
  Nexus.context = Tone.context;
  let poly = ["AMSynth", "DuoSynth", "FMSynth", "MonoSynth", "Synth"];

//   var position = new Nexus.Position('#masterdelay')

    // var masterdelayrack = new Nexus.Rack("#masterdelayrack",{
    //     attribute: 'data-nx'
    // })

    // masterdelayrack.freq.value = 0.25
    // masterdelayrack.volume.value = 0.5
    // masterdelayrack.mod.value = 0.75

    // masterdelayrack.freq.on('change',function(v) {
    // console.log(v);
    // })


    // var position = new Nexus.Position('#masterdelay',{
    // 'size': [200,200],
    // 'mode': 'absolute',  // "absolute" or "relative"
    // 'x': 0.5,  // initial x value
    // 'minX': 0,
    // 'maxX': 1,
    // 'stepX': 0,
    // 'y': 0.5,  // initial y value
    // 'minY': 0,
    // 'maxY': 1,
    // 'stepY': 0
    // })

    // position.on('change',function(v) {
    // console.log(v);


    // })

    




//   oscilloscope = new Nexus.Oscilloscope("#osci", {
//     size: [ 708, 53]
//   });
//   oscilloscope.colorize("fill", "#000");
//   oscilloscope.colorize("accent", "#3480bf");
//   oscilloscope.connect(Tone.Master);

//   let meter = new Nexus.Meter("#meter", {
//     size: [10, 53]
//   });
//   meter.colorize("fill", "#000");
//   meter.colorize("accent", "#3480bf");
//   meter.connect(Tone.Master);

//   piano = new Nexus.Piano("#piano", {
//     size: [300, 50],
//     mode: "button", // 'button', 'toggle', or 'impulse'
//     lowNote: 0,
//     highNote: 240
//   });
//   piano.colorize("accent", "#55b0e7");
//   piano.colorize("fill", "#66b0e7");

//   piano.on("change", v => {
//     if (v.state && inst1.synth) {
//       // the triggerAttack is different for Metal and Noise Synths
//       if (
//         inst1.controls.synthType == "MetalSynth" ||
//         inst1.controls.synthType == "NoiseSynth"
//       ) {
//         inst1.synth.triggerAttack();
//       } else {
//         inst1.synth.triggerAttack(Tone.Frequency(v.note, "midi").toNote());
//       }
//     } else if (poly.includes(inst1.controls.synthType)) {
//       inst1.synth.triggerRelease(Tone.Frequency(v.note, "midi").toNote());
//     } else if (inst1.synth) {
//       inst1.synth.triggerRelease(); // if synth is mono
//     }
//   });

//   function playNote(value) {
//     if (value[0] === 144 && value[2] != 0) {
//       piano.toggleKey(Tone.Frequency(value[1], "midi").toMidi(), true);
//     } else if (value[0] === 144 || value[0] === 128) {
//       piano.toggleKey(Tone.Frequency(value[1], "midi").toMidi(), false);
//     }
//   }

//   // got the MIDI code from here:
//   // https://github.com/kylestetz/AudioKeys

//   let keyboard = new AudioKeys({
//     polyphony: 8,
//     rows: 1,
//     priority: "last"
//   });

//   keyboard.down(note => {
//     if (note.note >= 0 && note.note <= 120) {
//       piano.toggleKey(note.note, true);
//     }
//   });

//   keyboard.up(note => {
//     if (note.note >= 0 && note.note <= 120) {
//       piano.toggleKey(note.note, false);
//     }
//   });

  // MIDI
  // https://codepen.io/Rumyra/pen/NxdbzL

  let midi, data;
  // start talking to MIDI controller
  if (navigator.requestMIDIAccess) {
    navigator
      .requestMIDIAccess({
        sysex: false
      })
      .then(onMIDISuccess, onMIDIFailure);
  } else {
    console.warn("No MIDI support in your browser");
  }

  // on success
  function onMIDISuccess(midiData) {
    // this is all our MIDI data
    midi = midiData;
    var allInputs = midi.inputs.values();
    // loop over all available inputs and listen for any MIDI input
    for (
      var input = allInputs.next();
      input && !input.done;
      input = allInputs.next()
    ) {
      // when a MIDI value is received call the onMIDIMessage function
      input.value.onmidimessage = gotMIDImessage;
    }
  }
  // var dataList = document.querySelector('#midi-data ul')

  function gotMIDImessage(messageData) {
    playNote(messageData.data);
  }

  // on failure
  function onMIDIFailure() {
    console.warn("Not recognising MIDI controller");
  }
}

class Synth {
  constructor(synthid) {
    this.synth = null;
    this.synthid = synthid
    this.guiSynth = new dat.GUI({
      autoPlace: true
    });
    this.guiSynth.DEFAULT_WIDTH = 600;
    this.guiSynthFolder = null;
    this.config = null;
    this.configMap = null;
    this.volumeObj = null;
    this.configString = null;
    this.fx = new Fx(this.synthid)
    this.controls = {
      synthType: "______choose a synth_______"
    };
    this._initSynthGui();
  }

  disconnect() {
    if (this.synth) this.synth.disconnect();
  }

  _initSynthGui() {
    let _this = this;

    this.guiSynth
      .add(this.controls, "synthType", [
        "__choose a synth__",
        "AMSynth",
        "DuoSynth",
        "FMSynth",
        "MembraneSynth",
        "MetalSynth",
        "MonoSynth",
        "NoiseSynth",
        "PluckSynth",
        "Synth"
      ])
      .onChange(function() {
        if (_this.controls.synthType != "__choose a synth__") {
          _this._initSynth(_this.controls.synthType);
          blurAll();
        }
      });
    this.guiSynth.width = 430;
    let guiContainer = document
      .getElementById("guiContainer")
      .appendChild(this.guiSynth.domElement);
  }
  _initSynth(type) {
    let poly = ["AMSynth", "DuoSynth", "FMSynth", "MonoSynth", "Synth"];
    let _this = this;
    

    //     if (poly.includes(type)) {
    //   this.synth = new Tone.PolySynth(8, Tone[type]);
    // } else {
    //   this.synth = new Tone[type]();
    // }


    if (this.synth) {
      //if synth exists
      this.synth.disconnect;
      this.synth.dispose();
      if (this.guiSynthFolder) {
        //if there is a folder
        this.guiSynth.removeFolder(this.guiSynthFolder);
      }
    }

    if (this == synth0) {

    if (poly.includes(type)) {
    this.synth = new Tone.PolySynth(8, Tone[type]);
    } else {
    this.synth = new Tone[type]();
    }

  }
//     if (this == synth1) {

//     if (poly.includes(type)) {
//     this.synth = new Tone.PolySynth(8, Tone[type]);
//     } else {
//     this.synth = new Tone[type]();
//     }

//   }


//     if (this == synth2) {

//     if (poly.includes(type)) {
//     this.synth = new Tone.PolySynth(8, Tone[type]);
//     } else {
//     this.synth = new Tone[type]();
//     }

//   }
//     if (this == synth3) {

//     if (poly.includes(type)) {
//     this.synth = new Tone.PolySynth(8, Tone[type]);
//     } else {
//     this.synth = new Tone[type]();
//     }

//   }


    // if (this == inst1) {

    //     this.synth = new Tone["Synth"]();
    // }
    // if (this == synth) {

    //     if (poly.includes(type)) {
    //   this.synth = new Tone.PolySynth(8, Tone[type]);
    // } else {
    //   this.synth = new Tone[type]();
    // }

    
    // }


    // if (poly.includes(type)) {
    //   this.synth = new Tone.PolySynth(8, Tone[type]);
    // } else {
    //   this.synth = new Tone[type]();
    // }



    if (this.fx.fx) {
      //add fx if there's one already created
      this.synth.disconnect();
      this.fx.updateFxChain();
    } else {
        // this.synth.connect(myAudioAnalyser)
        this.synth.toMaster();
    }
    this._initSynthFolder(type);
  }

  _initSynthFolder(type) {
    let _this = this;

    let _paramObj = {
      harmonicity: {
        min: 0,
        max: 20,
        step: 0.00001
      },
      modulationIndex: {
        min: 0,
        max: 1000,
        step: 0.00001
      },
      vibratoAmount: {
        min: 0,
        max: 100,
        step: 0.001
      },
      vibratoRate: {
        min: 0,
        max: 50,
        step: 0.001
      },
      portamento: {
        min: 0,
        max: 10,
        step: 0.001
      },
      pitchDecay: {
        min: 0,
        max: 2,
        step: 0.0001
      },
      octaves: {
        min: 0,
        max: 10,
        step: 0.0001
      },
      Q: {
        min: 0,
        max: 20,
        step: 0.0001
      },
      frequency: {
        min: 0.0001,
        max: 10000,
        step: 0.0001
      },
      baseFrequency: {
        min: 0,
        max: 10000,
        step: 0.0001
      },
      exponent: {
        min: 0,
        max: 10,
        step: 0.0001
      },
      resonance: {
        min: 0,
        max: 15000,
        step: 0.0001
      },
      volume: {
        min: -99,
        max: 0,
        step: 0.001
      },
      detune: {
        min: -100,
        max: 100,
        step: 0.001
      },
      attack: {
        min: 0.001,
        max: 10,
        step: 0.0001
      },
      decay: {
        min: 0.001,
        max: 1,
        step: 0.0001
      },
      sustain: {
        min: 0.001,
        max: 1,
        step: 0.0001
      },
      release: {
        min: 0.001,
        max: 20,
        step: 0.0001
      },
      partials: {
        min: 0.001,
        max: 20,
        step: 0.0001
      },
      attackNoise: {
        min: 0.1,
        max: 20,
        step: 0.0001
      },
      dampening: {
        min: 0,
        max: 10000,
        step: 0.0001
      }
    };

    // get the default synth config
    this.config = Object.assign(Tone[type].defaults);

    if (typeof this.configMap == "defined") {
      this.configMap.clear();
    }

    //create Map
    this.configMap = new Map(Object.entries(this.config)); // a entry for controlling synth volume

    //add a volume entry that balances some differences between synth types volumes
    if (type == "DuoSynth" || type == "MembraneSynth") {
      this.volumeObj = {
        volume: -6
      };
    } else if (
      type == "MetalSynth" ||
      type == "MonoSynth" ||
      type == "NoiseSynth"
    ) {
      this.volumeObj = {
        volume: -20
      };
    } else {
      this.volumeObj = {
        volume: -3
      };
    }

    this.synth.volume.value = this.volumeObj.volume;
    this.guiSynthFolder = _this.guiSynth.addFolder(type);
    this.guiSynthFolder.open();

    // adding a volume control first on gui
    this.guiSynthFolder
      .add(this.volumeObj, "volume", -50, 0, 0.01)
      .name("synthVolume (db)")
      .onChange(function() {
        _this.synth.volume.value = _this.volumeObj.volume;
      });

    // Iterate over synth default parameters
    for (var [key, value] of this.configMap) {
      if (typeof key == "string" && typeof value == "number") {
        let paramName = key; // e.g. harmonicity, detune
        _this.guiSynthFolder
          .add(
            this.config,
            key,
            _paramObj[key].min,
            _paramObj[key].max,
            _paramObj[key].step
          )
          .onChange(function() {
            _this.synth.set(paramName, _this.config[paramName]);
          });
      }

      if (typeof value == "object") {
        // if there's a nested object
        let _objFolder = this.guiSynthFolder.addFolder(key);
        _objFolder.open();
        let subMap = new Map(Object.entries(value));
        let synthParam = key; //store name of parameter for synth.set
        let subObj = value; //store sub object for gui
        for (var [key, value] of subMap) {
          if (typeof key == "string" && typeof value == "number") {
            let param = key; //store control name for onChange
            let paramValue = value; //stores numerical param
            if (key == "rolloff" || key == "type") {
            } else {
              _objFolder
                .add(
                  subObj,
                  key,
                  _paramObj[key].min,
                  _paramObj[key].max,
                  _paramObj[key].step
                )
                .name(synthParam.concat(".", param))
                .onChange(function() {
                  _this.synth.set(synthParam.concat(".", param), subObj[param]);
                });
            }
          } else if (typeof key == "string") {
            let synthParamType = key; //store name of parameter for synth.set
            let param = value; //store control name for onChange
            if (synthParam == "envelope") {
              _objFolder
                .add(subObj, key, [
                  "exponential",
                  "linear",
                  "sine",
                  "cosine",
                  "bounce",
                  "ripple",
                  "step"
                ])
                .name(synthParam.concat(".", synthParamType))
                .onChange(function() {
                  blurAll();
                });
            } else if (
              synthParam == "oscillator" ||
              synthParam == "modulation"
            ) {
              _objFolder
                .add(subObj, key, [
                  "square",
                  "sine",
                  "triangle",
                  "sawtooth",
                  "pwm",
                  "pulse",
                  "fatsquare",
                  "fatsine",
                  "fattriangle",
                  "fatsawtooth",
                  "fmsquare",
                  "fmsine",
                  "fmtriangle",
                  "fmsawtooth",
                  "amsquare",
                  "amsine",
                  "amtriangle",
                  "amsawtooth"
                ])
                .name(synthParam.concat(".", synthParamType))
                .onChange(function() {
                  _this.synth.set(
                    synthParam.concat(".", synthParamType),
                    subObj[synthParamType]
                  );
                  blurAll();
                });
              // adding partials
              subObj.partials = 0;
              _objFolder
                .add(subObj, "partials", [0, 1, 2, 4, 8, 16, 32, 64, 128])
                .onChange(function() {
                  let osc = subObj[synthParamType].concat(subObj.partials);
                  if (
                    subObj[synthParamType] != "pwm" &&
                    subObj[synthParamType] != "pulse"
                  ) {
                    _this.synth.set(
                      synthParam.concat(".", synthParamType),
                      osc
                    );
                  }
                  blurAll();
                });
            } else if (synthParam == "noise") {
              _objFolder
                .add(subObj, key, ["white", "pink", "brown"])
                .name(synthParam.concat(".", synthParamType))
                .onChange(function() {
                  _this.synth.set(
                    synthParam.concat(".", synthParamType),
                    subObj.type
                  );
                  blurAll();
                  _this.synth.envelope.sustain = 1;
                });
            }
          }

          // This is just for DuoSynth

          if (typeof value == "object") {
            //if there's another nested object
            let subSubMap = new Map(Object.entries(value));
            let synthParamSubType = key; //oscillator or filterEnvelope or Envelope
            let subObj = value;
            let synthParamType = key; //store name of parameter for synth.set

            for (var [key, value] of subSubMap) {
              if (synthParamSubType == "oscillator") {
                _objFolder
                  .add(subObj, key, [
                    "square",
                    "sine",
                    "triangle",
                    "sawtooth",
                    "pwm",
                    "pulse",
                    "fatsquare",
                    "fatsine",
                    "fattriangle",
                    "fatsawtooth",
                    "fmsquare",
                    "fmsine",
                    "fmtriangle",
                    "fmsawtooth",
                    "amsquare",
                    "amsine",
                    "amtriangle",
                    "amsawtooth"
                  ])
                  .name(synthParam.concat(".", key))
                  .onChange(function() {
                    _this.synth.set(
                      synthParam
                        .concat(".", synthParamSubType)
                        .concat(".", Object.entries(subObj)[0][0]),
                      Object.entries(subObj)[0][1]
                    );
                    blurAll();
                  });
              } else {
                _objFolder
                  .add(
                    subObj,
                    key,
                    _paramObj[key].min,
                    _paramObj[key].max,
                    _paramObj[key].step
                  )
                  .name(
                    synthParam.concat(".", synthParamSubType).concat(".", key)
                  )
                  .onChange(function() {
                    _this.synth.set(
                      synthParam
                        .concat(".", synthParamSubType)
                        .concat(".", key),
                      subObj[key]
                    );
                  });
                blurAll();
              }
            }
          }
        }
      }
    }
  }
}

class Fx {
  constructor(synthid) {
    this.fx = null;
    this.fxChain = [];
    this.volume = new Tone.Volume(-3);
    this.fxChainEnd = [this.volume, Tone.Master];
    this.configFxMap = null;
    this.synthid = synthid;
    this.initControls = {
      addFx: "AMSynth"
    };
    this.guiFx = new dat.GUI({
      autoPlace: true
    });
    this.folder = null;
    this._initGui();
    this.remove = function() {};
  }

  _initGui() {
    let _this = this;

    this.guiContainer = document
      .getElementById("guiFxContainer")
      .appendChild(this.guiFx.domElement);
    this.guiFx.width = 280;

    this.guiFx
      .add(this.initControls, "addFx", [
        "___insert an effect___",
        "AutoFilter",
        "AutoPanner",
        "AutoWah",
        "BitCrusher",
        "Chebyshev",
        "Chorus",
        "Distortion",
        "FeedbackDelay",
        "Freeverb",
        "JCReverb",
        "Phaser",
        "PingPongDelay",
        "PitchShift",
        "Tremolo",
        "Vibrato",
        "Compressor",
        "MultibandCompressor",
        "EQ3",
        "FeedbackCombFilter",
        "Filter",
        "Limiter",
        "LowpassCombFilter"
      ])
      .name("addFx (max: 8)")
      .onChange(function() {
        if (_this.initControls.addFx != "___insert an effect___") {
          _this.folder = _this.guiFx.addFolder(_this.initControls.addFx);
          _this.folder.open();
          _this._initFx(_this.initControls.addFx);
          blurAll();
        }
      });

    var initVol = {
      effectsVolume: -3
    };
    this.guiFx
      .add(initVol, "effectsVolume", -48, 0, 0.001)
      .name("fxVolume (db)")
      .onChange(function() {
        // _this.volume.volume.rampTo(initVol.effectsVolume, 0.2);
        _this.volume.volume.value = initVol.effectsVolume;
        blurAll();
      });
  }

  _initFx(fxType) {
    if (this.fxChain.length < 8) {
      this.fx = new Tone[fxType]();
      //starts fx if is one ot these three below
      if (
        fxType == "AutoFilter" ||
        fxType == "AutoPanner" ||
        fxType == "Tremolo"
      )
        this.fx.start();
      this.fxChain.push(this.fx); //adds to the fx _fxChain
      this._initFxControls(fxType);
      this.updateFxChain();
    } else {
      window.alert("There's a limit of 8 insert effects.");
    }
  }

  updateFxChain() {
    let fxChainComplete = this.fxChain.concat(this.fxChainEnd); //adding fx to volume and Tone.Master

    console.log(this.synthid)
    if (this.synthid == 0) {
      console.log("you are here")    
      synth0.synth.disconnect();
      var source = synth0.synth;
      
    
    }
    // else if (this.synthid ==  1) {
    //   synth1.synth.disconnect();
    //   var source = synth1.synth;
    
    // }
    // else if (this.synthid ==  2) {
    //   synth2.synth.disconnect();
    //   var source = synth2.synth;
  
      
    // }
    // else {
    //   synth3.synth.disconnect();
    //   var source = synth3.synth;
    
    // }
    
      for (var i = 0; i < fxChainComplete.length; i++) {
        //a loop for connecting the fx
        source.connect(fxChainComplete[i]);
        source = fxChainComplete[i];
      }
    

    

    
    // if (synth.synth) {
    //   synth.synth.disconnect();
    //   let source = synth.synth;

    //   for (var i = 0; i < fxChainComplete.length; i++) {
    //     //a loop for connecting the fx
    //     source.connect(fxChainComplete[i]);
    //     source = fxChainComplete[i];
    //   }
    // }
  


    // if (inst1.synth) {
    //   inst1.synth.disconnect();
    //   let source = inst1.synth;

    //   for (var i = 0; i < fxChainComplete.length; i++) {
    //     //a loop for connecting the fx
    //     source.connect(fxChainComplete[i]);
    //     source = fxChainComplete[i];
    //   }
    // }
  }

  _initFxControls(fxType) {
    // get the default synth config
    let _configFxObj = Object.assign(Tone[fxType].defaults);

    let _this = this;
    let _fx = this.fx;
    let _folder = this.folder;
    let _paramFxObj = {
      frequency: {
        min: 0.0001,
        max: 10000,
        step: 0.00001
      },
      baseFrequency: {
        min: 0,
        max: 10000,
        step: 0.00001
      },
      depth: {
        min: 0,
        max: 1,
        step: 0.00001
      },
      octaves: {
        min: 0,
        max: 10,
        step: 0.00001
      },
      Q: {
        min: 0,
        max: 10,
        step: 0.00001
      },
      stages: {
        min: 0,
        max: 10,
        step: 0.00001
      },
      sensitivity: {
        min: -36,
        max: 12,
        step: 0.00001
      },
      gain: {
        min: 0,
        max: 20,
        step: 0.00001
      },
      ratio: {
        min: 1,
        max: 20,
        step: 0.00001
      },
      threshold: {
        min: -99,
        max: 0,
        step: 0.00001
      },
      knee: {
        min: 0,
        max: 40,
        step: 0.00001
      },
      attack: {
        min: 0.001,
        max: 1,
        step: 0.00001
      },
      release: {
        min: 0.001,
        max: 1,
        step: 0.00001
      },
      bits: {
        min: 4,
        max: 8,
        step: 0.0001
      },
      order: {
        min: 1,
        max: 8,
        step: 1
      },
      delayTime: {
        min: 0,
        max: 1,
        step: 0.0001
      },
      maxDelayTime: {
        min: 0,
        max: 1,
        step: 0.0001
      },
      pitch: {
        min: -36,
        max: 36,
        step: 0.0001
      },
      feedback: {
        min: 0,
        max: 1,
        step: 0.0001
      },
      width: {
        min: 0,
        max: 1,
        step: 0.0001
      },
      decay: {
        min: 0,
        max: 5,
        step: 0.0001
      },
      preDelay: {
        min: 0,
        max: 1,
        step: 0.0001
      },
      windowSize: {
        min: 0.03,
        max: 0.1,
        step: 0.0001
      },
      roomSize: {
        min: 0,
        max: 1,
        step: 0.0001
      },
      dampening: {
        min: 0,
        max: 10000,
        step: 0.0001
      },
      spread: {
        min: 0,
        max: 180,
        step: 0.0001
      },
      distortion: {
        min: 0,
        max: 1,
        step: 0.0001
      },
      maxDelay: {
        min: 0,
        max: 10,
        step: 0.0001
      },
      resonance: {
        min: 0,
        max: 1,
        step: 0.0001
      },
      oversample: {
        values: ["none", "2x", "4x"]
      },
      type: {
        values: ["square", "sine", "triangle", "sawtooth"]
      },
      "filter.type": {
        values: [
          "lowpass",
          "highpass",
          "bandpass",
          "lowshelf",
          "highshelf",
          "notch",
          "allpass",
          "peaking"
        ]
      },
      rolloff: {
        values: ["-12", "-12", "-24", "-48", "-96"]
      },
      highFrequency: {
        min: 0,
        max: 10000,
        step: 0.0001
      },
      lowFrequency: {
        min: 0,
        max: 10000,
        step: 0.0001
      },
      low: {
        min: -24,
        max: 0,
        step: 0.0001
      },
      high: {
        min: -24,
        max: 0,
        step: 0.0001
      },
      mid: {
        min: -24,
        max: 0,
        step: 0.0001
      }
    };

    //this prevents a excessive range on frequency parameter for Phaser(danger!), Vibrato and Tremolo effects.
    if (fxType == "Phaser" || fxType == "Tremolo" || fxType == "Vibrato") {
      _paramFxObj.frequency.max = 30;
    }

    // clear Map
    if (this.configFxMap) {
      this.configFxMap.clear();
    }

    //create Map
    this.configFxMap = new Map(Object.entries(_configFxObj)); // a entry for controlling synth volume
    let _configFxMap = this.configFxMap;

    var initialFxControls = {
      removeFx: function() {
        let tempVol = _this.volume.volume.value;
        _this.volume.volume.rampTo(-99, 1); //fadeOut
        _fx.dispose();
        let index = _this.fxChain.indexOf(_fx);
        _this.fxChain.splice(index, 1); // deletes the fx
        _this.updateFxChain(); //update the synth.chain()
        _this.guiFx.removeFolder(_folder);
        _configFxMap.clear();
        _this.volume.volume.rampTo(tempVol, 1); //fadeIn
      },
      wet: 1
    };
    //

    // adding a wet and volume control first on gui
    this.folder.add(initialFxControls, "removeFx");
    this.folder.add(initialFxControls, "wet", 0, 1, 0.001).onChange(function() {
      _this.fx.set("wet", initialFxControls.wet);
      blurAll();
    });

    // Iterate over fx default parameters
    for (var [key, value] of this.configFxMap) {
      let _fx = this.fx;
      let paramName = key; // e.g. harmonicity, detune
      if (typeof key == "string" && typeof value != "object") {
        if (_paramFxObj[key].hasOwnProperty("min")) {
          this.folder
            .add(
              _configFxObj,
              key,
              _paramFxObj[key].min,
              _paramFxObj[key].max,
              _paramFxObj[key].step
            )
            .onChange(function() {
              _fx.set(paramName, _configFxObj[paramName]);
              blurAll();
            });
        } else if (value == "lowpass") {
          this.folder
            .add(_configFxObj, key, [
              "lowpass",
              "highpass",
              "bandpass",
              "lowshelf",
              "highshelf",
              "notch",
              "allpass",
              "peaking"
            ])
            .name(paramName)
            .onChange(function() {
              _fx.set(paramName, _configFxObj[paramName]);
              blurAll();
            });
        } else {
          this.folder
            .add(_configFxObj, key, _paramFxObj[key].values)
            .name(key)
            .onChange(function() {
              _fx.set(paramName, _configFxObj[paramName]);
              blurAll();
            });
        }
      } else {
        if (typeof value == "object") {
          // if there's a nested object
          let subMap = new Map(Object.entries(value));
          let fxParam = key; //store name of parameter for synth.set
          let subObj = value; //store sub object for gui
          for (var [key, value] of subMap) {
            let param = key; //store control name for onChange
            let paramValue = value; //stores numerical param
            if (_paramFxObj[key].hasOwnProperty("min")) {
              this.folder
                .add(
                  subObj,
                  key,
                  _paramFxObj[key].min,
                  _paramFxObj[key].max,
                  _paramFxObj[key].step
                )
                .name(fxParam.concat(".", param))
                .onChange(function() {
                  _fx.set(fxParam.concat(".", param), subObj[param]);
                  blurAll();
                });
            } else {
              if (fxParam == "filter" && param == "type") {
                this.folder
                  .add(subObj, key, [
                    "lowpass",
                    "highpass",
                    "bandpass",
                    "lowshelf",
                    "highshelf",
                    "notch",
                    "allpass",
                    "peaking"
                  ])
                  .name(fxParam.concat(".", param))
                  .onChange(function() {
                    _fx.set(fxParam.concat(".", param), subObj[param]);
                    blurAll();
                  });
              } else {
                this.folder
                  .add(subObj, key, _paramFxObj[key].values)
                  .name(fxParam.concat(".", param))
                  .onChange(function() {
                    _fx.set(fxParam.concat(".", param), subObj[param]);
                  });
              }
            }
          }
        }
      }
    }
  }
}

start()
synthtracks = {}
  synth0 = new Synth(0)
//   synth1 = new Synth(1)
//   synth2 = new Synth(2)
//   synth3 = new Synth(3)
window.oncontextmenu = function(event) {
     event.preventDefault();
     event.stopPropagation();
     return false;
};


var canvas = document.createElement('canvas')
// canvas.id = "canvas2"
var ctx = canvas.getContext("2d")
canvas.id = "canvas1";
canvas.width = 1000;
canvas.height = 1000;
canvas.style.zIndex = 8;
canvas.style.touchAction = "none"
canvas.style.position = "absolute";
canvas.style.border = "1px solid";
canvas.style.backgroundColor = "black"
var body = document.getElementsByTagName("body")[0];
body.appendChild(canvas);

cursorLayer = document.getElementById("canvas1");
    
// synth0 = new Synth(0)
  var s = new CanvasState(canvas);
  
//   s.addShape(new Shape(40,40,50,50)); // The default is gray
//   s.addShape(new Shape(60,140,40,60, 'lightskyblue'));
//   // Lets make some partially transparent
//   s.addShape(new Shape(80,150,60,30, 'rgba(127, 255, 212, .5)'));
//   s.addShape(new Shape(125,80,30,80, 'rgba(245, 222, 179, .7)'));




  function getRandomColor() {
  var letters = '0123456789ABCDEF';
  var color = '#';
  for (var i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)];
  }
  return color;
}

var numberOfSides = 12,
    size = canvas.width/2.2,
    Xcenter = canvas.width/2-50,
    Ycenter = Xcenter;

// synth0 = new Synth()

// scalenotes = ["A3","A#3","B3","C4","C#4","D4","D#4","E4","F4","F#4","G4","G#4"]

scalenotes = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"]
scalecolor = []
for (i =0; i <= scalenotes.length; i++) {
    color = getRandomColor()
    scalecolor.push(color)

}
// scalecolor = ["A","A#","B","C","C#","D","D#","E","F","F#","G","G#"]


// sacredshapes = {}
// var c = document.getElementById("myCanvas");
// var ctx = c.getContext("2d");
// ctx.strokeStyle = "#FF0000";
// ctx.strokeRect(20, 20, 150, 100);
// // var c = document.getElementById("myCanvas");
// // var ctx = c.getContext("2d");
// ctx.beginPath();
// ctx.moveTo(20, 20);
// ctx.lineTo(20, 100);
// ctx.lineTo(70, 100);
// ctx.stroke();
for (j = 0; j <=2; j++) {
  
  for (i = 0; i <=numberOfSides-1; i++) {
      let x = Xcenter + (size - j*size/4) * Math.sin((i) * 2 * Math.PI / numberOfSides)
          ,y =  Ycenter - (size - j*size/4) * Math.cos((i) * 2 * Math.PI / numberOfSides)
      s.addShape(new Shape(x,y,80,80,scalecolor[i],synth0,scalenotes[i]+(5-j)),scalenotes[i]+(5-j))
    //   console.log(s.shapes[scalenotes[i]+(6-j)])
    //   console.log(scalenotes[i]+(6-j))
      

for (l = 0; l <=0  ; l++) {
     
  for (m = 0; m <=12; m++) {
      let x1 = Xcenter + (size - l*size/4) * Math.sin((m) * 2 * Math.PI / numberOfSides)+40
          ,y1 =  Ycenter - (size - l*size/4) * Math.cos((m) * 2 * Math.PI / numberOfSides)+40
    //   s.addShape(new Shape(x,y,120,120,scalecolor[i],synth0,scalenotes[i]+(5-j)),scalenotes[i]+(5-j))
    ctx.beginPath();
    ctx.globalAlpha = 0.8
    ctx.lineWidth = j
ctx.moveTo(x+40, y+40);
ctx.strokeStyle = scalecolor[i]
ctx.lineTo(x1, y1);
// ctx.
// ctx.lineTo(70, 100);
ctx.stroke();
ctx.closePath()
// ctx.globalAlpha  = 1
    //   // cxt.moveTo(x,y)
    //   ctx.moveTo(x,y)  
    //   ctx.strokeStyle = getRandomColor();
    //   ctx.lineWidth = 10
    //   ctx.beginPath();
    // //   console.log(x1,y1,x,y)
    //   ctx.lineTo(x1,y1)
      
      
    //   ctx.stroke()
    //   ctx.closePath()

      // cxt.arc(x,y, 50, 0, 2 * Math.PI)
      // cxt.closePath()

      // cxt.lineWidth = 1;
      // cxt.fill();
  }
  }
 
  }

}
s.draw()
function start() {
//   console.clear()
  // initial Tone.Js setup
  
//   Tone.setContext(context);
//   Tone.Transport.start();
//   synth = new Synth()
  // fx = new Fx(); //new fx rack with synth as source
  Tone.context.latencyHint = "fastest";
  Tone.context.lookAhead = 0.01;

initNexus()
//   initNexus();
//   inst1 = new Synth();
  
  // synth = new Synth()

}


    








// cxt.moveTo (Xcenter +  size * Math.cos(1), Ycenter +  size *  Math.sin(0));          






// for (var j = 1; j <= numberOfSides; j += 1) {
//     console.log(j)
//     cxt.lineTo (Xcenter + size * Math.cos(j * 2 * Math.PI / numberOfSides), Ycenter + size * Math.sin(j * 2 * Math.PI / numberOfSides));
//     console.log(Xcenter + size * Math.cos(j * 2 * Math.PI / numberOfSides))
//     console.log(Ycenter + size * Math.sin(j * 2 * Math.PI / numberOfSides))
//     for (var k = 1; k <= numberOfSides; k +=1){
//         // cxt.lineTo (Xcenter + size * Math.cos((k) * 2 * Math.PI / numberOfSides), Ycenter + size * Math.sin((k) * 2 * Math.PI / numberOfSides));
//         for (var i = 1; i <= numberOfSides;i += 1) {
//         console.log(i)
//         cxt.lineTo (Xcenter + size * Math.cos((i+k) * 2 * Math.PI / numberOfSides), Ycenter + size * Math.sin((i+k) * 2 * Math.PI / numberOfSides));
//         console.log(Xcenter + size * Math.cos(i * 2 * Math.PI / numberOfSides))
//     console.log(Ycenter + size * Math.sin(i * 2 * Math.PI / numberOfSides))

//     }
   

        
//     }
// }
// cxt.strokeStyle = "black";
// cxt.lineWidth = 1;
// cxt.stroke();



</script>


</body>
</html>